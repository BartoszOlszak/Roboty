#include "NXT++.h"
#include <iostream>
#include <conio.h>
#include <vector>
#include <iomanip>
using namespace std;
using namespace NXT;

Comm::NXTComm comm;

//PRZED UŻYCIEM SPRZETU DOKŁADNIE SPRAWDZAMY: 
//DO KTÓRYCH PORTÓW WEJŚCIOWYCH (IN) PODŁĄCZONE SĄ SENSORY,\
//DO KTÓRYCH PORTÓW WYJŚCIOWYCH (OUT) PODŁĄCZONE SĄ SERVO-MOTORY,
//STARAMY SIĘ PISAC KOD Z MOŻLIWOŚCIĄ ZATRZYMANIA ROBOTA W KAŻDEJ CHWILI,
//ROBOT POWIENIEN BYC PRZEMIESZCZONY W MIEJSCE TESTÓW ZA POŚREDNICTWEM ZDALNEGO STEROWANIA,
//CZUJNIKI SA INICJOWANE PRZED PETLA NIESKONCZONA,
//CZUJNIKI SA DEAKTYWOWANE ZA PETLA NIESKONCZONA, LUB PO KOMENDZIE k,

int convert(int k, int orient) { // funkcja pokazuje ile stopni od orientu jest cel (minusowe wartosci to orient jest na lewo od celu)
	orient = orient - k;
	if (orient > 180) orient = orient - 360;
	else if (orient < -180) orient = 360 + orient;
	return orient;
}


vector<int> steer(int k1, int k2, int k, int orient, int ksi) {
	int cte = convert(k, orient);
	if (cte == 0) {
		k1 = 20;
		k2 = 20;
	}
	else if (cte < 0) {
		if (abs(cte) > k1) { // k1 to predkosc lewego kola
			k2 = 0;
		}
		else {
			k2 = k1 + (ksi * cte);
		}
	}

	else if (cte > 0) {
		if (cte > k2) {
			k1 = 0;
		}
		else {
			k1 = k2 - (ksi * cte);
		}
	}
	vector<int> v;
	v.push_back(k1);
	v.push_back(k2);
	return v;
}


struct RGB {
	int r;
	int g;
	int b;
};


const RGB C_WHITE = { 525, 417, 381 };
const RGB C_GREEN = { 265, 359, 306 };
const RGB C_RED = { 523, 245, 236 };
const RGB C_BLACK = { 219,  133,  129 };


bool rangeRGB(int r, int g, int b, const RGB& x) {
	return (r >= x.r - 50 && r <= x.r + 50) &&
		(g >= x.g - 50 && g <= x.g + 50) &&
		(b >= x.b - 50 && b <= x.b + 50);
}


int matchColors(int r, int g, int b) {
	if (rangeRGB(r, g, b, C_WHITE)) return 0;
	if (rangeRGB(r, g, b, C_GREEN)) return 1;
	if (rangeRGB(r, g, b, C_RED))   return 2;
	if (rangeRGB(r, g, b, C_BLACK)) return 3;
	return -1;
}

string whichColor(int color) {
	switch (color) {
	case 0: return "bialy";
	case 1: return "zielony";
	case 2: return "czerwony";
	case 3: return "czarny";
	default: return "nieznany";
	}
}

void firstPosition(int map[3][5], int currentColor, double probMap[3][5]) {
	int count = 0;

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			if (map[y][x] == currentColor) {
				count++;
			}
		}
	}

	if (count == 0) {
		return;
	}

	double prob = 1.0 / count;

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			if (map[y][x] == currentColor) {
				probMap[y][x] = prob;
			}
			else {
				probMap[y][x] = 0.0;
			}
		}
	}
}


void normalize(double probMap[3][5]) {
	double sum = 0.0;

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			sum += probMap[y][x];

	if (sum == 0.0) return;

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			probMap[y][x] /= sum;
}


void senseColor(int map[3][5], int currentColor, double probMap[3][5]) {
	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			if (map[y][x] != currentColor) {
				probMap[y][x] = 0.0;
			}
		}
	}
	normalize(probMap);
}


void moveNorth(double mapProb[3][5]) {
	double next[3][5] = { 0 };

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			int newX = x + 1;
			if (newX >= 0 && newX < 5) {
				next[y][newX] += mapProb[y][x];
			}
		}
	}

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			mapProb[y][x] = next[y][x];
}


void moveEast(double mapProb[3][5]) {
	double next[3][5] = { 0 };

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			int newY = y + 1;
			if (newY >= 0 && newY < 3) {
				next[newY][x] += mapProb[y][x];
			}
		}
	}

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			mapProb[y][x] = next[y][x];
}


void moveSouth(double mapProb[3][5]) {
	double next[3][5] = { 0 };

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			int newX = x - 1;
			if (newX >= 0 && newX < 5) {
				next[y][newX] += mapProb[y][x];
			}
		}
	}

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			mapProb[y][x] = next[y][x];
}


void moveWest(double mapProb[3][5]) {
	double next[3][5] = { 0 };

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			int newY = y - 1;
			if (newY >= 0 && newY < 3) {
				next[newY][x] += mapProb[y][x];
			}
		}
	}

	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			mapProb[y][x] = next[y][x];
}


void printMaxProbPosition(double probMap[3][5]) {
	double maxProb = 0.0;
	int maxY = -1, maxX = -1;

	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			if (probMap[y][x] > maxProb) {
				maxProb = probMap[y][x];
				maxY = y;
				maxX = x;
			}
		}
	}

	cout << "Robot z najwiekszym prawdopodobienstwem P = " << maxProb
		<< " znajduje sie na polu: (" << maxY << "," << maxX << ")" << endl;
}



void printProbMap(double probMap[3][5]) {
	cout << "\nRozklad prawdopodobienstwa wynosi wynosi:\n";
	for (int y = 0; y < 3; y++) {
		for (int x = 0; x < 5; x++) {
			cout << fixed << setprecision(2) << probMap[y][x] << "\t";
		}
		cout << endl;
	}
}



void resetProbMap(double probMap[3][5]) {
	double prob = 1.0 / 15.0;
	for (int y = 0; y < 3; y++)
		for (int x = 0; x < 5; x++)
			probMap[y][x] = prob;
}


int main()
{
	srand(time(NULL));

	cout << "Szukanie sygnalu... to moze zajac chwile.\n";
	if (NXT::OpenBT(&comm)) //initialize the NXT and continue if it succeeds
	{
		cout << "Sygnal znaleziony!";
		cout << "\nPoziom baterii = " << NXT::BatteryLevel(&comm);
		cout << "\nDostepna pamiec flash = " << NXT::GetAvailableFlash(&comm);

		int x = 20;//szybkość jazdy w przód i tył
		int xtemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		int y = 20;//szybkość obrotu w lewo, prawo
		int ytemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		char last_value;//zapamietana ostatnia instrukcja sterująca

		//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		//NXT::Sensor::SetTouch(&comm, IN_1);//inicjacja sensora dotyku

		//aktywacja czujnika koloru
		NXT::Sensor::SetColor(&comm, IN_3, 'n');
		NXT::Sensor::SetSonar(&comm, IN_2);
		Wait(50);
		int color;
		int k1 = 20;
		int k2 = 20;
		int ksi = 1;
		int orientacja;
		int r, g, b;
		int target = 0;
		int lastMoveTarget = target;
		bool didMove = false;
		bool firstMeasurement = true;

		int map[3][5] = {
		{1, 2, 0, 2, 0},
		{0, 3, 1, 0, 2},
		{1, 2, 0, 2, 3}
		};

		double probMap[3][5];


		//początek programu
		NXT::StartProgram(&comm, "program1");

		//zmienna używana do sterowania
		char decyzja;
		char c;

		cout << "\n ___Podstawowe sterowanie do uzupelnienia___";
		cout << "\n A - jazda w lewo";
		cout << "\n D - jazda w prawo";
		cout << "\n W - jazda na wprost";
		cout << "\n S - jazda do tylu";
		cout << "\n U - odczyt z sonaru";
		cout << "\n C - odczyt nasycenia koloru";
		cout << "\n H - Zatrzymanie silnikow";
		cout << "\n Z - Histogram";
		cout << "\n K - Koniec Programu";

		while (true) {
			if (_kbhit()) {
				char c = getch();

				if (c == 'X' || c == 'x')
				{
					NXT::Motor::SetForward(&comm, OUT_C, 0);
					NXT::Motor::SetForward(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
					NXT::Motor::Stop(&comm, OUT_B, 0);
					break;
				}

				if (c == 'W' || c == 'w') {  //potem zobaczyc reset i firstMes i didMOve, jezeli nie trzeba klikac po kazdym polu do odkomentowac
					target = 0;
					//resetProbMap(probMap);
					//didMove = false;
					//firstMeasurement = true;
					cout << "\nRobot jedzie na polnoc\n";
				}
				else if (c == 'D' || c == 'd') {
					target = 90;
					//resetProbMap(probMap);
					//didMove = false;
					//firstMeasurement = true;
					cout << "\nRobot jedzie na wschod\n";
				}
				else if (c == 'S' || c == 's') {
					target = 180;
					//resetProbMap(probMap);
					//didMove = false;
					//firstMeasurement = true;
					cout << "\nRobot jedzie na poludnie\n";
				}
				else if (c == 'A' || c == 'a') {
					target = 270;
					//resetProbMap(probMap);
					//didMove = false;
					//firstMeasurement = true;
					cout << "\nRobot jedzie na zachod\n";
				}
			}

			orientacja = 2 * NXT::Sensor::GetSonarValue(&comm, IN_3);
			Wait(50);
			int cte = convert(target, orientacja);

			if (cte > 2) {  // ewentualnie dostosowac
				NXT::Motor::SetForward(&comm, OUT_B, 10);
				NXT::Motor::SetReverse(&comm, OUT_C, 10);
			}
			else if (cte < -2) {
				NXT::Motor::SetForward(&comm, OUT_C, 10);
				NXT::Motor::SetReverse(&comm, OUT_B, 10);
			}
			Wait(100);

			if (cte >= -2 && cte <= 2) {
				NXT::Motor::Stop(&comm, OUT_B, true);
				NXT::Motor::Stop(&comm, OUT_C, true);

				NXT::Sensor::SetColor(&comm, IN_3, 'r');
				Wait(100);
				r = NXT::Sensor::GetValue(&comm, IN_3);

				NXT::Sensor::SetColor(&comm, IN_3, 'g');
				Wait(100);
				g = NXT::Sensor::GetValue(&comm, IN_3);

				NXT::Sensor::SetColor(&comm, IN_3, 'b');
				Wait(100);
				b = NXT::Sensor::GetValue(&comm, IN_3);


				cout << "R: " << r << "   G: " << g << "   B: " << b << endl;
				int colorId = matchColors(r, g, b);
				string colorName = whichColor(colorId);
				if (colorId != -1) {
					cout << "Kolor " << colorName << endl;

					if (firstMeasurement) {
						firstPosition(map, colorId, probMap);
						firstMeasurement = false;
					}

					else {
						if (didMove) {
							if (lastMoveTarget == 0)      moveNorth(probMap);
							else if (lastMoveTarget == 90)  moveEast(probMap);
							else if (lastMoveTarget == 180) moveSouth(probMap);
							else if (lastMoveTarget == 270) moveWest(probMap);
						}
						senseColor(map, colorId, probMap);
					}
					printProbMap(probMap);
					cout << " \n\n\n";
					printMaxProbPosition(probMap);
				}

				else {
					cout << "Nie wykryto koloru" << endl;
					printProbMap(probMap);
					cout << " \n\n\n";
					printMaxProbPosition(probMap);
				}

				vector<int> v1 = steer(k1, k2, target, orientacja, ksi);
				NXT::Motor::SetForward(&comm, OUT_C, k1);
				NXT::Motor::SetForward(&comm, OUT_B, k2);
				cout << "\n\n\nRobot w trakcie ruchu...\n\n\n";
				Wait(3600);
				NXT::Motor::Stop(&comm, OUT_B, true);
				NXT::Motor::Stop(&comm, OUT_C, true);
				lastMoveTarget = target;
				didMove = true;
				Wait(100);
				continue;
			}
		}

		NXT::StopProgram(&comm);

	}
	NXT::Close(&comm); //close communication with NXT

	cout << "\n\nPress ENTER to close program";
	getchar();

	return 0;
}


//opcje dotyczace Mindstorm NXT v. 1.0

//if(decyzja=='L' || decyzja=='l')
// {
//  NXT::Sensor::SetLight(&comm, IN_3, 1);
//  Wait(50);
//  cout<<"LightValue = "<<NXT::Sensor::GetValue(&comm, IN_3);
//  Wait(50);
//  NXT::Sensor::SetLight(&comm, IN_3, 0);
// }

	//if(decyzja=='O' || decyzja=='o')
// {
// NXT::Sensor::SetSound(&comm, IN_2);
// Wait(50);
// cout<<"SoundValue = "<<NXT::Sensor::GetValue(&comm, IN_2);
// }
