#include "NXT++.h"
#include <iostream>
#include <conio.h>
#include <vector>
#include <iomanip>
using namespace std;
using namespace NXT;

Comm::NXTComm comm;

//PRZED UŻYCIEM SPRZETU DOKŁADNIE SPRAWDZAMY: 
//DO KTÓRYCH PORTÓW WEJŚCIOWYCH (IN) PODŁĄCZONE SĄ SENSORY,\
//DO KTÓRYCH PORTÓW WYJŚCIOWYCH (OUT) PODŁĄCZONE SĄ SERVO-MOTORY,
//STARAMY SIĘ PISAC KOD Z MOŻLIWOŚCIĄ ZATRZYMANIA ROBOTA W KAŻDEJ CHWILI,
//ROBOT POWIENIEN BYC PRZEMIESZCZONY W MIEJSCE TESTÓW ZA POŚREDNICTWEM ZDALNEGO STEROWANIA,
//CZUJNIKI SA INICJOWANE PRZED PETLA NIESKONCZONA,
//CZUJNIKI SA DEAKTYWOWANE ZA PETLA NIESKONCZONA, LUB PO KOMENDZIE k,

int convert(int k, int orient) { // funkcja pokazuje ile stopni od orientu jest cel (minusowe wartosci to orient jest na lewo od celu)
	orient = orient - k;
	if (orient > 180) orient = orient - 360;
	else if (orient < -180) orient = 360 + orient;
	return orient;
}


vector<int> steer(int k1, int k2, int k, int orient, int ksi) {
	int cte = convert(k, orient);
	if (cte == 0) {
		k1 = 30;
		k2 = 30;
	}
	else if (cte < 0) {
		if (abs(cte) > k1) { // k1 to predkosc lewego kola
			k2 = 0;
		}
		else {
			k2 = k1 + (ksi * cte);
		}
	}

	else if (cte > 0) {
		if (cte > k2) {
			k1 = 0;
		}
		else {
			k1 = k2 - (ksi * cte);
	}
	}
	vector<int> v;
	v.push_back(k1);
	v.push_back(k2);
	return v;
}


struct RGB {
    int r;
    int g;
    int b;
};


const RGB C_WHITE = { 525, 417, 381 };
const RGB C_GREEN = { 265, 359, 306 };
const RGB C_RED = { 523, 245, 236 };
const RGB C_BLACK = { 219,  133,  129 };


bool rangeRGB(int r, int g, int b, const RGB& x) {
    return (r >= x.r - 50 && r <= x.r + 50) &&
           (g >= x.g - 50 && g <= x.g + 50) &&
           (b >= x.b - 50 && b <= x.b + 50);
}


int matchColors(int r, int g, int b) {
    if (rangeRGB(r, g, b, C_WHITE)) return 0;
    if (rangeRGB(r, g, b, C_GREEN)) return 1;
    if (rangeRGB(r, g, b, C_RED))   return 2;
    if (rangeRGB(r, g, b, C_BLACK)) return 3;
    return -1;
}

string whichColor(int color){
	switch (color) {
        case 0: return "bialy";
        case 1: return "zielony";
        case 2: return "czerwony";
        case 3: return "czarny";
        default: return "nieznany"; 
    }
}

void firstPosition(int map[3][5], int currentColor, double probMap[3][5]) {
    int count = 0;

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] == currentColor) {
                count++;
            }
        }
    }

    if (count == 0) {
        return;
    }

    double prob = 1.0 / count;

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] == currentColor) {
                probMap[y][x] = prob;
            }
            else {
                probMap[y][x] = 0.0;
            }
        }
    }
}


void normalize(double probMap[3][5]) {
    double sum = 0.0;

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            sum += probMap[y][x];

    if (sum == 0.0) return;

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            probMap[y][x] /= sum;
}


void senseColor(int map[3][5], int currentColor, double probMap[3][5]) {
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] != currentColor) {
                probMap[y][x] = 0.0;
            }
        }
    }
    normalize(probMap);
}


void moveNorth(double mapProb[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newX = x + 1;
            if (newX >= 0 && newX < 5) {
                next[y][newX] += mapProb[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            mapProb[y][x] = next[y][x];
}


void moveEast(double mapProb[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newY = y + 1;
            if (newY >= 0 && newY < 3) {
                next[newY][x] += mapProb[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            mapProb[y][x] = next[y][x];
}


void moveSouth(double mapProb[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newX = x - 1;
            if (newX >= 0 && newX < 5) {
                next[y][newX] += mapProb[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            mapProb[y][x] = next[y][x];
}


void moveWest(double mapProb[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newY = y - 1;
            if (newY >= 0 && newY < 3) {
                next[newY][x] += mapProb[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            mapProb[y][x] = next[y][x];
}


void printMaxProbPosition(double probMap[3][5]) {
    double maxProb = 0.0;
    int maxY = -1, maxX = -1;

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (probMap[y][x] > maxProb) {
                maxProb = probMap[y][x];
                maxY = y;
                maxX = x;
            }
        }
    }

    cout << "Robot z najwiekszym prawdopodobienstwem P = " << maxProb 
     << " znajduje sie na polu: (" << maxY << "," << maxX << ")" << endl;
}



void printProbMap(double probMap[3][5]) {
    cout << "\nRozklad prawdopodobienstwa wynosi wynosi:\n";
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            cout << fixed << setprecision(2) << probMap[y][x] << "\t";
        }
        cout << endl;
    }
}



void resetProbMap(double probMap[3][5]) {
    double prob = 1.0 / 15.0;
    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            probMap[y][x] = prob;
}


int main()
{
	srand(time(NULL));

	cout << "Szukanie sygnalu... to moze zajac chwile.\n";
	if (NXT::OpenBT(&comm)) //initialize the NXT and continue if it succeeds
	{
		cout << "Sygnal znaleziony!";
		cout << "\nPoziom baterii = " << NXT::BatteryLevel(&comm);
		cout << "\nDostepna pamiec flash = " << NXT::GetAvailableFlash(&comm);

		int x = 20;//szybkość jazdy w przód i tył
		int xtemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		int y = 20;//szybkość obrotu w lewo, prawo
		int ytemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		char last_value;//zapamietana ostatnia instrukcja sterująca

		//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		//NXT::Sensor::SetTouch(&comm, IN_1);//inicjacja sensora dotyku

		//aktywacja czujnika koloru
		NXT::Sensor::SetColor(&comm, IN_2, 'n');
		NXT::Sensor::SetSonar(&comm, IN_3);
		Wait(50);
		int color;
		int k1 = 30;
		int k2 = 30;
		int ksi = 1;
		int orientacja;
		int r, g, b;
		int target = 0;
		int lastMoveTarget = target;
		bool didMove = false;
		bool firstMeasurement = true;

		int map[3][5] = {
		{1, 2, 0, 2, 0},
		{0, 3, 1, 0, 2},
		{1, 2, 0, 2, 3}
		};

		double probMap[3][5];

		//początek programu
		NXT::StartProgram(&comm, "program1");

		//zmienna używana do sterowania
		char decyzja;

		cout << "\n ___Podstawowe sterowanie do uzupelnienia___";
		cout << "\n A - jazda w lewo";
		cout << "\n D - jazda w prawo";
		cout << "\n W - jazda na wprost";
		cout << "\n S - jazda do tylu";
		cout << "\n U - odczyt z sonaru";
		cout << "\n C - odczyt nasycenia koloru";
		cout << "\n H - Zatrzymanie silnikow";
		cout << "\n Z - Histogram";
		cout << "\n K - Koniec Programu";

		do
		{
			//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		/*
		if(NXT::Sensor::GetValue(&comm, IN_1)==1)
			{
			for(int i=1;i<1000;i=i+10)
				{
				NXT::PlayTone(&comm, i, 1);
				Wait(1);
				}
			}
		*/

			if (kbhit() == true)
			{

				decyzja = getch();

				if (decyzja == 'N' || decyzja == 'n')
				{
					x -= 10;
				}

				if (decyzja == 'M' || decyzja == 'm')
				{
					x += 10;
				}

				if (decyzja == 'V' || decyzja == 'v')
				{
					y--;
				}

				if (decyzja == 'B' || decyzja == 'b')
				{
					y++;
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'H' || decyzja == 'h')
				{
					NXT::Motor::SetForward(&comm, OUT_B, 0);
					NXT::Motor::SetForward(&comm, OUT_C, 0);
					NXT::Motor::Stop(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'K' || decyzja == 'k')
				{
					NXT::Motor::Stop(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
					NXT::Motor::Stop(&comm, OUT_A, 0);
					NXT::Sensor::SetSonarOff(&comm, IN_1);
					NXT::Sensor::SetColorOff(&comm, IN_2);

					break;
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				if (decyzja == 'U' || decyzja == 'u')
				{
					cout << " Wskazanie sonaru = " << NXT::Sensor::GetSonarValue(&comm, IN_1);
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				if (decyzja == 'C' || decyzja == 'c')
				{
					color = NXT::Sensor::GetValue(&comm, IN_2);
					Wait(50);
					cout << "\nNasycenie swaitla = " << color;
				}




                if (decyzja == 'Z' || decyzja == 'z') // jazda z radarem
				{
					resetProbMap(probMap); //to to
					while (true) {
						if (_kbhit()) {
							char c = _getch();

							if (c == 'X' || c == 'x')
							{
								NXT::Motor::SetForward(&comm, OUT_C, 0);
								NXT::Motor::SetForward(&comm, OUT_B, 0);
								NXT::Motor::Stop(&comm, OUT_C, 0);
								NXT::Motor::Stop(&comm, OUT_B, 0);
								break;
							}

							if (c == 'W' || c == 'w') {  //potem zobaczyc reset i firstMes i didMOve, jezeli nie trzeba klikac po kazdym polu do odkomentowac
								target = 0;
								//resetProbMap(probMap);
								//didMove = false;
								//firstMeasurement = true;
								cout << "\nRobot jedzie na polnoc\n";
							}
							else if (c == 'D' || c == 'd') {
								target = 90;
								//resetProbMap(probMap);
								//didMove = false;
								//firstMeasurement = true;
								cout << "\nRobot jedzie na wschod\n";
							}
							else if (c == 'S' || c == 's') {
								target = 180;
								//resetProbMap(probMap);
								//didMove = false;
								//firstMeasurement = true;
								cout << "\nRobot jedzie na poludnie\n";
							}
							else if (c == 'A' || c == 'a') {
								target = 270;
								//resetProbMap(probMap);
								//didMove = false;
								//firstMeasurement = true;
								cout << "\nRobot jedzie na zachod\n";
							}
						}

						orientacja = 2 * NXT::Sensor::GetSonarValue(&comm, IN_3);
						Wait(50);
						int cte = convert(target, orientacja);

						cout << "cte: " << cte << endl;

	
						if (cte > 2) {  // ewentualnie dostosowac
							NXT::Motor::SetForward(&comm, OUT_B, 10);
							NXT::Motor::SetReverse(&comm, OUT_C, 10);
						}
						else if (cte < -2) {
							NXT::Motor::SetForward(&comm, OUT_C, 10);
							NXT::Motor::SetReverse(&comm, OUT_B, 10);
						}
						Wait(100);

						if (cte >= -2 and cte <= 2) {
							NXT::Motor::Stop(&comm, OUT_B, true);
							NXT::Motor::Stop(&comm, OUT_C, true);
							
							NXT::Sensor::SetColor(&comm, IN_2, 'r');
							Wait(100);
							r = NXT::Sensor::GetValue(&comm, IN_2);

							NXT::Sensor::SetColor(&comm, IN_2, 'g');
							Wait(100);
							g = NXT::Sensor::GetValue(&comm, IN_2);

							NXT::Sensor::SetColor(&comm, IN_2, 'b');
							Wait(100);
							b = NXT::Sensor::GetValue(&comm, IN_2);


							cout << "R: " << r << "   G: " << g << "   B: " << b << endl;
							int colorId = matchColors(r, g, b);
							string colorName = whichColor(colorId);
							if (colorId != -1) {
								cout << "Kolor " << colorName << endl;

								if (firstMeasurement) {
									firstPosition(map, colorId, probMap);
									firstMeasurement = false;
								}

								else {
									if (didMove) {
										if (lastMoveTarget == 0)      moveNorth(probMap);
										else if (lastMoveTarget == 90)  moveEast(probMap);
										else if (lastMoveTarget == 180) moveSouth(probMap);
										else if (lastMoveTarget == 270) moveWest(probMap);
									}
									senseColor(map, colorId, probMap);
								}
								printProbMap(probMap);
								printMaxProbPosition(probMap);
							}

							else {
								cout << "Blad koloru" << endl;
							}

							vector<int> v1 = steer(k1, k2, target, orientacja, ksi);
							k1 = v1[0];
							k2 = v1[1];
							NXT::Motor::SetForward(&comm, OUT_C, k1);
							NXT::Motor::SetForward(&comm, OUT_B, k2);
							cout << "\n\n\n\nczekamy ~5 sekund\n\n\n\n";
							Wait(4800);
							NXT::Motor::Stop(&comm, OUT_B, true);
							NXT::Motor::Stop(&comm, OUT_C, true);
							lastMoveTarget = target;
							didMove = true;
							Wait(100);
							continue;
						}
					}
				}


				NXT::Sensor::SetColorOff(&comm, IN_2);
				NXT::Sensor::SetSonarOff(&comm, IN_3);

				continue;
			}
		} while (decyzja != 'k' && decyzja != 'K');

		NXT::StopProgram(&comm);

	}
	NXT::Close(&comm); //close communication with NXT

	cout << "\n\nPress ENTER to close program";
	getchar();

	return 0;
}


//opcje dotyczace Mindstorm NXT v. 1.0

//if(decyzja=='L' || decyzja=='l')
// {
//  NXT::Sensor::SetLight(&comm, IN_3, 1);
//  Wait(50);
//  cout<<"LightValue = "<<NXT::Sensor::GetValue(&comm, IN_3);
//  Wait(50);
//  NXT::Sensor::SetLight(&comm, IN_3, 0);
// }

	//if(decyzja=='O' || decyzja=='o')
// {
// NXT::Sensor::SetSound(&comm, IN_2);
// Wait(50);
// cout<<"SoundValue = "<<NXT::Sensor::GetValue(&comm, IN_2);
// }