#include "NXT++.h"
#include <iostream>
#include <conio.h>
#include <iomanip>


using namespace std;
using namespace NXT;

Comm::NXTComm comm;




int convert(int k, int x) {
    x = x - k;

    if (x > 180) 
        x = x - 360;
    else if (x < -180)
        x = 360 + x;

    return x;
}




void steer(int& k1, int& k2, int k, int orient, double ksi) {
    int cte = convert(k, orient);


    if (cte <= 0) {
        if (abs(cte) > k1) {
            k2 = k1 * (-1);
        }
        else {
            k2 = k1 + (ksi * cte);
        }
    }


    if (cte > 0) {
        if (cte > k2) {
            k1 = k2 * (-1);
        }
        else {
            k1 = k2 - (ksi * cte);
        }
    }

    cout << "orient=" << orient << "  cte=" << cte << "  k1=" << k1 << "  k2=" << k2 << endl;
}




struct RGB {
    int r;
    int g;
    int b;
};


const RGB C_WHITE = { 525, 417, 381 };
const RGB C_GREEN = { 265, 359, 306 };
const RGB C_RED = { 523, 245, 236 };
const RGB C_BLACK = { 219,  133,  129 };



bool inRange(int v, int center) {
    return (v >= center - 50) && (v <= center + 50);
}

bool matchRGB(int r, int g, int b, const RGB& c) {
    return inRange(r, c.r) && inRange(g, c.g) && inRange(b, c.b);
}

int classifyWithTolerance(int r, int g, int b) {
    if (matchRGB(r, g, b, C_WHITE)) return 0;
    if (matchRGB(r, g, b, C_GREEN)) return 1;
    if (matchRGB(r, g, b, C_RED))   return 2;
    if (matchRGB(r, g, b, C_BLACK)) return 3;
    return -1;
}

void computePositionFromColor(
int map[3][5],
int seenColor,
double belief[3][5]
) {
    int count = 0;
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] == seenColor) {
                count++;
            }
        }
    }

    if (count == 0) {
        return;
    }

    double prob = 1.0 / count;
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] == seenColor) {
                belief[y][x] = prob;
            }
            else {
                belief[y][x] = 0.0;
            }
        }
    }
}

void normalize(double belief[3][5]) {
    double sum = 0.0;

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            sum += belief[y][x];

    if (sum == 0.0) return;

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] /= sum;
}


void senseColor(
    int map[3][5],
    int seenColor,
    double belief[3][5]
) {
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (map[y][x] != seenColor) {
                belief[y][x] = 0.0;
            }
        }
    }
    normalize(belief);
}


void moveNorth(double belief[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newX = x + 1;     
            if (newX >= 0 && newX < 5) {
                next[y][newX] += belief[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] = next[y][x];
}

void moveSouth(double belief[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newX = x - 1;
            if (newX >= 0 && newX < 5) {
                next[y][newX] += belief[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] = next[y][x];
}

void moveEast(double belief[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newY = y + 1;   
            if (newY >= 0 && newY < 3) {
                next[newY][x] += belief[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] = next[y][x];
}

void moveWest(double belief[3][5]) {
    double next[3][5] = { 0 };

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            int newY = y - 1; 
            if (newY >= 0 && newY < 3) {
                next[newY][x] += belief[y][x];
            }
        }
    }

    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] = next[y][x];
}

void printMostProbable(double belief[3][5]) {
    double maxP = 0.0;
    int bestY = -1, bestX = -1;

    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            if (belief[y][x] > maxP) {
                maxP = belief[y][x];
                bestY = y;
                bestX = x;
            }
        }
    }

    cout << "Robot z najwiekszym prawdopodobienstwem P = " << maxProb 
     << " znajduje sie na polu: (" << maxY << "," << maxX << ")" << endl;
}

void printBelief(double belief[3][5]) {
    cout << "\nRozklad prawdopodobienstwa wynosi wynosi:\n";
    for (int y = 0; y < 3; y++) {
        for (int x = 0; x < 5; x++) {
            cout << fixed << setprecision(2) << belief[y][x] << "\t";
        }
        cout << endl;
    }
}

void resetBelief(double belief[3][5]) {
    double p = 1.0 / 15.0;
    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 5; x++)
            belief[y][x] = p;
}


int main() {
    if (!NXT::OpenBT(&comm)) {
        cout << "Brak połączenia." << endl;
        return 11;
    }

    int r, g, b;

    NXT::Sensor::SetSonar(&comm, IN_2);
    Wait(50);
        
    double ksi = 0.2;
    int target = 0;

    int lastMoveTarget = target;
    bool didMove = false;

    int k1 = 10;
    int k2 = 10;
    
    int table[3][5] = {
    {1, 2, 0, 2, 0},
    {0, 3, 1, 0, 2},
    {1, 2, 0, 2, 3}
    };

    double belief[3][5];
    bool firstMeasurement = true;

    while (true) {
        if (_kbhit()) {
            char c = _getch();

            if (c == 'q' || c == 'Q') {
                NXT::Motor::SetForward(&comm, OUT_C, 0);
                NXT::Motor::SetForward(&comm, OUT_B, 0);
                break;
            }

            if (c == 'b' || c == 'B') {
                NXT::Motor::SetForward(&comm, OUT_C, 0);
                NXT::Motor::SetForward(&comm, OUT_B, 0);
                didMove = false;           
                firstMeasurement = true;
            }

            if (c == 'w' || c == 'W') {
                target = 0;
                resetBelief(belief);
                didMove = false;          
                firstMeasurement = true;
                cout << "\nRobot jedzie na polnoc\n";
            }
            else if (c == 'd' || c == 'D') {
                target = 90;
                resetBelief(belief);
                didMove = false;         
                firstMeasurement = true;
                cout << "\nRobot jedzie na wschod\n";
            }
            else if (c == 's' || c == 'S') {
                target = 180;
                resetBelief(belief);
                didMove = false; 
                firstMeasurement = true;
                cout << "\nRobot jedzie na poludnie\n";
            }
            else if (c == 'a' || c == 'A') {
                target = 270;
                resetBelief(belief);
                didMove = false;         
                firstMeasurement = true;
                cout << "\nRobot jedzie na zachod\n";
            }
        }

        int raw = NXT::Sensor::GetSonarValue(&comm, IN_2);
        int orient = raw * 2;           
        
        if (orient < 0)      orient += 360;   
        if (orient >= 360)   orient -= 360;
        


        int cte = convert(target, orient);


        cout << "cte=" << cte << endl;


        if (abs(cte) > 5) {
            if (cte > 0) {
                NXT::Motor::SetForward(&comm, OUT_B, 5);
                NXT::Motor::SetReverse(&comm, OUT_C, 5);
            }
            else {
                NXT::Motor::SetReverse(&comm, OUT_B, 5);
                NXT::Motor::SetForward(&comm, OUT_C, 5);
            }
            Wait(100);
            continue;
        }


        if (abs(cte) < 5) {
            NXT::Motor::Stop(&comm, OUT_B, true);
            NXT::Motor::Stop(&comm, OUT_C, true);
            NXT::Sensor::SetColor(&comm, IN_3, 'r');
            Wait(100);
            r = NXT::Sensor::GetValue(&comm, IN_3);

            NXT::Sensor::SetColor(&comm, IN_3, 'g');
            Wait(100);
            g = NXT::Sensor::GetValue(&comm, IN_3);

            NXT::Sensor::SetColor(&comm, IN_3, 'b');
            Wait(100);
            b = NXT::Sensor::GetValue(&comm, IN_3);


            cout << "R: " << r << "   G: " << g << "   B: " << b << endl;
            int colorId = classifyWithTolerance(r, g, b);
            if (colorId != -1) {
                cout << "Color " << colorId << endl;

                if (firstMeasurement) {
                    computePositionFromColor(table, colorId, belief);
                    firstMeasurement = false;
                }
                else {
                    if (didMove) {
                        if (lastMoveTarget == 0)      moveNorth(belief);
                        else if (lastMoveTarget == 180) moveSouth(belief);
                        else if (lastMoveTarget == 270) moveWest(belief);
                        else if (lastMoveTarget == 90)  moveEast(belief);
                    }

                    senseColor(table, colorId, belief);
                }



                printBelief(belief);
                printMostProbable(belief);
            }
            else {
                cout << "Blad koloru" << endl;
            }

            steer(k1, k2, target, orient, ksi);
            NXT::Motor::SetForward(&comm, OUT_C, k1);
            NXT::Motor::SetForward(&comm, OUT_B, k2);
            cout << "\n\n\n\n\n\n\nczekamy 7.2 sekund\n\n\n\n\n\n\n\n";
            Wait(7200);
            NXT::Motor::Stop(&comm, OUT_B, true);
            NXT::Motor::Stop(&comm, OUT_C, true);
            lastMoveTarget = target; 
            didMove = true;
            Wait(2000);
            continue;
        }  
    }
                    
    NXT::Sensor::SetColorOff(&comm, IN_2);
    NXT::Sensor::SetSonarOff(&comm, IN_3);
    return 0;
}
